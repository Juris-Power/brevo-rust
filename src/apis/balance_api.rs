/*
 * Brevo API
 *
 * Brevo provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/brevo  **Possible responses**   | Code | Message |   | :-------------: | ------------- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |   | 406  | Error. Not Acceptable  |   | 422  | Error. Unprocessable Entity |
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: contact@brevo.com
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`begin_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BeginTransactionError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelTransactionError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`complete_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompleteTransactionError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_balance_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBalanceLimitError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status424(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_balance_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBalanceOrderError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_balance_definition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBalanceDefinitionError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_balance_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBalanceLimitError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_balance_definition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBalanceDefinitionError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_balance_definition_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBalanceDefinitionListError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_balance_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBalanceLimitError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_contact_balances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContactBalancesError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_subscription_balances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubscriptionBalancesError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`loyalty_balance_programs_pid_active_balance_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoyaltyBalanceProgramsPidActiveBalanceGetError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`loyalty_balance_programs_pid_balance_definitions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoyaltyBalanceProgramsPidBalanceDefinitionsPostError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`loyalty_balance_programs_pid_subscriptions_cid_balances_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoyaltyBalanceProgramsPidSubscriptionsCidBalancesPostError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`loyalty_balance_programs_pid_transaction_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoyaltyBalanceProgramsPidTransactionHistoryGetError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_balance_definition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateBalanceDefinitionError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status424(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_balance_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateBalanceLimitError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// Creates new transaction and returns information
pub async fn begin_transaction(
    configuration: &configuration::Configuration,
    pid: &str,
    create_transaction_payload: models::CreateTransactionPayload,
) -> Result<models::Transaction, Error<BeginTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_create_transaction_payload = create_transaction_payload;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/transactions",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };
    req_builder = req_builder.json(&p_create_transaction_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Transaction`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Transaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BeginTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Cancels transaction
pub async fn cancel_transaction(
    configuration: &configuration::Configuration,
    pid: &str,
    tid: &str,
) -> Result<models::Transaction, Error<CancelTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_tid = tid;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/transactions/{tid}/cancel",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid),
        tid = crate::apis::urlencode(p_tid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Transaction`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Transaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Completes transaction
pub async fn complete_transaction(
    configuration: &configuration::Configuration,
    pid: &str,
    tid: &str,
) -> Result<models::Transaction, Error<CompleteTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_tid = tid;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/transactions/{tid}/complete",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid),
        tid = crate::apis::urlencode(p_tid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Transaction`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Transaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompleteTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates balance limit and sends the created UUID along with the data
pub async fn create_balance_limit(
    configuration: &configuration::Configuration,
    pid: &str,
    bdid: &str,
    create_balance_limit_payload: models::CreateBalanceLimitPayload,
) -> Result<models::BalanceLimit, Error<CreateBalanceLimitError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_bdid = bdid;
    let p_create_balance_limit_payload = create_balance_limit_payload;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/balance-definitions/{bdid}/limits",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid),
        bdid = crate::apis::urlencode(p_bdid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };
    req_builder = req_builder.json(&p_create_balance_limit_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BalanceLimit`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BalanceLimit`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateBalanceLimitError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns created order
pub async fn create_balance_order(
    configuration: &configuration::Configuration,
    pid: &str,
    create_order_payload: models::CreateOrderPayload,
) -> Result<models::BalanceOrder, Error<CreateBalanceOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_create_order_payload = create_order_payload;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/create-order",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };
    req_builder = req_builder.json(&p_create_order_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BalanceOrder`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BalanceOrder`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateBalanceOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete Balance definition
pub async fn delete_balance_definition(
    configuration: &configuration::Configuration,
    pid: &str,
    bdid: &str,
) -> Result<(), Error<DeleteBalanceDefinitionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_bdid = bdid;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/balance-definitions/{bdid}",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid),
        bdid = crate::apis::urlencode(p_bdid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteBalanceDefinitionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete balance limit
pub async fn delete_balance_limit(
    configuration: &configuration::Configuration,
    pid: &str,
    bdid: &str,
    blid: &str,
) -> Result<(), Error<DeleteBalanceLimitError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_bdid = bdid;
    let p_blid = blid;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/balance-definitions/{bdid}/limits/{blid}",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid),
        bdid = crate::apis::urlencode(p_bdid),
        blid = crate::apis::urlencode(p_blid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteBalanceLimitError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns balance definition
pub async fn get_balance_definition(
    configuration: &configuration::Configuration,
    pid: &str,
    bdid: &str,
    version: Option<&str>,
) -> Result<models::BalanceDefinition, Error<GetBalanceDefinitionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_bdid = bdid;
    let p_version = version;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/balance-definitions/{bdid}",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid),
        bdid = crate::apis::urlencode(p_bdid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BalanceDefinition`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BalanceDefinition`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBalanceDefinitionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns balance definition page
pub async fn get_balance_definition_list(
    configuration: &configuration::Configuration,
    pid: &str,
    limit: Option<i32>,
    offset: Option<i32>,
    sort_field: Option<&str>,
    sort: Option<&str>,
    version: Option<&str>,
) -> Result<models::BalanceDefinitionPage, Error<GetBalanceDefinitionListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_limit = limit;
    let p_offset = offset;
    let p_sort_field = sort_field;
    let p_sort = sort;
    let p_version = version;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/balance-definitions",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BalanceDefinitionPage`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BalanceDefinitionPage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBalanceDefinitionListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fetches balance limits and send the created UUID along with the data
pub async fn get_balance_limit(
    configuration: &configuration::Configuration,
    pid: &str,
    bdid: &str,
    blid: &str,
    version: Option<&str>,
) -> Result<models::BalanceLimit, Error<GetBalanceLimitError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_bdid = bdid;
    let p_blid = blid;
    let p_version = version;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/balance-definitions/{bdid}/limits/{blid}",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid),
        bdid = crate::apis::urlencode(p_bdid),
        blid = crate::apis::urlencode(p_blid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BalanceLimit`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BalanceLimit`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBalanceLimitError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns balance list
pub async fn get_contact_balances(
    configuration: &configuration::Configuration,
    pid: &str,
) -> Result<models::ContactBalancesResp, Error<GetContactBalancesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/contact-balances",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContactBalancesResp`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContactBalancesResp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetContactBalancesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns subscription balances
pub async fn get_subscription_balances(
    configuration: &configuration::Configuration,
    cid: &str,
    pid: &str,
) -> Result<models::ModelSubscriptionBalanceResp, Error<GetSubscriptionBalancesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cid = cid;
    let p_pid = pid;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/subscriptions/{cid}/balances",
        configuration.base_path,
        cid = crate::apis::urlencode(p_cid),
        pid = crate::apis::urlencode(p_pid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ModelSubscriptionBalanceResp`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ModelSubscriptionBalanceResp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubscriptionBalancesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns Active Balances
pub async fn loyalty_balance_programs_pid_active_balance_get(
    configuration: &configuration::Configuration,
    pid: &str,
    contact_id: i32,
    balance_definition_id: &str,
    limit: Option<i32>,
    offset: Option<i32>,
    sort_field: Option<&str>,
    sort: Option<&str>,
) -> Result<models::BalanceLimit, Error<LoyaltyBalanceProgramsPidActiveBalanceGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_contact_id = contact_id;
    let p_balance_definition_id = balance_definition_id;
    let p_limit = limit;
    let p_offset = offset;
    let p_sort_field = sort_field;
    let p_sort = sort;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/active-balance",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_field {
        req_builder = req_builder.query(&[("sort_field", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("contact_id", &p_contact_id.to_string())]);
    req_builder = req_builder.query(&[(
        "balance_definition_id",
        &p_balance_definition_id.to_string(),
    )]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BalanceLimit`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BalanceLimit`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoyaltyBalanceProgramsPidActiveBalanceGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates balance definition and returns information
pub async fn loyalty_balance_programs_pid_balance_definitions_post(
    configuration: &configuration::Configuration,
    pid: &str,
    create_balance_definition_payload: models::CreateBalanceDefinitionPayload,
) -> Result<models::BalanceDefinition, Error<LoyaltyBalanceProgramsPidBalanceDefinitionsPostError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_create_balance_definition_payload = create_balance_definition_payload;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/balance-definitions",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };
    req_builder = req_builder.json(&p_create_balance_definition_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BalanceDefinition`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BalanceDefinition`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoyaltyBalanceProgramsPidBalanceDefinitionsPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a balance for a contact
pub async fn loyalty_balance_programs_pid_subscriptions_cid_balances_post(
    configuration: &configuration::Configuration,
    pid: &str,
    cid: &str,
    create_balance_payload: models::CreateBalancePayload,
) -> Result<models::Balance, Error<LoyaltyBalanceProgramsPidSubscriptionsCidBalancesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_cid = cid;
    let p_create_balance_payload = create_balance_payload;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/subscriptions/{cid}/balances",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid),
        cid = crate::apis::urlencode(p_cid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };
    req_builder = req_builder.json(&p_create_balance_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Balance`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Balance`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoyaltyBalanceProgramsPidSubscriptionsCidBalancesPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns transaction history
pub async fn loyalty_balance_programs_pid_transaction_history_get(
    configuration: &configuration::Configuration,
    pid: &str,
    contact_id: i32,
    balance_definition_id: &str,
    limit: Option<i32>,
    offset: Option<i32>,
    sort_field: Option<&str>,
    sort: Option<&str>,
    filters: Option<Vec<String>>,
) -> Result<
    models::TransactionHistoryResp,
    Error<LoyaltyBalanceProgramsPidTransactionHistoryGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_contact_id = contact_id;
    let p_balance_definition_id = balance_definition_id;
    let p_limit = limit;
    let p_offset = offset;
    let p_sort_field = sort_field;
    let p_sort = sort;
    let p_filters = filters;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/transaction-history",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_field {
        req_builder = req_builder.query(&[("sort_field", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("contact_id", &p_contact_id.to_string())]);
    req_builder = req_builder.query(&[(
        "balance_definition_id",
        &p_balance_definition_id.to_string(),
    )]);
    if let Some(ref param_value) = p_filters {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("filters".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "filters",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TransactionHistoryResp`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TransactionHistoryResp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoyaltyBalanceProgramsPidTransactionHistoryGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates Balance definition
pub async fn update_balance_definition(
    configuration: &configuration::Configuration,
    pid: &str,
    bdid: &str,
    update_balance_definition_payload: models::UpdateBalanceDefinitionPayload,
) -> Result<models::BalanceDefinition, Error<UpdateBalanceDefinitionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_bdid = bdid;
    let p_update_balance_definition_payload = update_balance_definition_payload;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/balance-definitions/{bdid}",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid),
        bdid = crate::apis::urlencode(p_bdid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };
    req_builder = req_builder.json(&p_update_balance_definition_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BalanceDefinition`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BalanceDefinition`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateBalanceDefinitionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates balance limit
pub async fn update_balance_limit(
    configuration: &configuration::Configuration,
    pid: &str,
    bdid: &str,
    blid: &str,
    update_balance_limit_payload: models::UpdateBalanceLimitPayload,
) -> Result<models::BalanceLimit, Error<UpdateBalanceLimitError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pid = pid;
    let p_bdid = bdid;
    let p_blid = blid;
    let p_update_balance_limit_payload = update_balance_limit_payload;

    let uri_str = format!(
        "{}/loyalty/balance/programs/{pid}/balance-definitions/{bdid}/limits/{blid}",
        configuration.base_path,
        pid = crate::apis::urlencode(p_pid),
        bdid = crate::apis::urlencode(p_bdid),
        blid = crate::apis::urlencode(p_blid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("api-key", value);
    };
    req_builder = req_builder.json(&p_update_balance_limit_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BalanceLimit`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BalanceLimit`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateBalanceLimitError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
